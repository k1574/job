#!/usr/bin/env python3

import copy
import tkinter.filedialog as fd
import tkinter as Tk
from PIL import Image, ImageTk

class Rgb:
	def __init__(self):
		self.RED = 0
		self.GREEN = 1
		self.BLUE = 2
		self.LUM = 3
		self.COLORS = [self.RED, self.GREEN, self.BLUE]
		self.LUMS = [0.3, 0.59, 0.11]
		self.MAXVAL = 255
		self.FNLIST = [self.R, self.G, self.B, self.L]

	def R(self, px):
		return px[self.RED]
	def G(self, px):
		return px[self.GREEN]
	def B(self, px):
		return px[self.BLUE]

	def L(self, px):
		v = 0
		i = 0
		for l in self.LUMS :
			v += px[i] * l
			i += 1
		return int(v)

RGB = Rgb()
class App:
	FirstTime = True
	CursorBorderWidth = 5
	IntensifyVal = 5
	ModKey = "<Control-%s>"
	HistoHeight = 100
	HistoWidth = RGB.MAXVAL+1
	def __init__(self):
		self.Root = Tk.Tk()
		self.Root.bind("n", self.loadNewImage)
		self.Root.bind(self.ModKey % "n",
			lambda a: self.negativeColor())
		self.Root.bind("r",
			lambda a: self.intensifyColor([RGB.RED], self.IntensifyVal))
		self.Root.bind(self.ModKey % "r",
			lambda a: self.intensifyColor([RGB.RED], -self.IntensifyVal))
		self.Root.bind("g",
			lambda a: self.intensifyColor([RGB.GREEN], self.IntensifyVal))
		self.Root.bind(self.ModKey % "g",
			lambda a: self.intensifyColor([RGB.GREEN], -self.IntensifyVal))
		self.Root.bind("b",
			lambda a: self.intensifyColor([RGB.BLUE], self.IntensifyVal))
		self.Root.bind(self.ModKey % "b",
			lambda a: self.intensifyColor([RGB.BLUE], -self.IntensifyVal))
		self.Root.bind("l",
			lambda a: self.intensifyColor(RGB.COLORS, self.IntensifyVal))
		self.Root.bind(self.ModKey % "l",
			lambda a: self.intensifyColor(RGB.COLORS, -self.IntensifyVal))
		self.Root.bind("h", lambda a: self.mirrorH())
		self.Root.bind("v", lambda a: self.mirrorV())

		# Define main variables.
		self.Image = None
		self.Photo = None
		self.RGB = None
		self.Canvas = None

		self.loadNewImage()

	def Start(self):
		self.Root.mainloop()

	def intensifyColor(self, colors, val):
		s = list(self.Image.split())
		for c in colors :
			s[c] = s[c].point(lambda i: i + val)
		self.Image = Image.merge("RGB", tuple(s))
		self.updateImage(self.Image)

	def negativeColor(self):
		s = list(self.Image.split())
		for c in RGB.COLORS :
			s[c] = s[c].point(lambda v: RGB.MAXVAL - v)
		self.Image = Image.merge("RGB", tuple(s))
		self.updateImage(self.Image)

	def mirrorH(self):
		im = Image.new(mode="RGB", size=self.Image.size)
		w, h = self.Image.size
		for i in range(h) :
			for j in range(w) :
				im.putpixel(
					(j, i),
					self.Image.getpixel((w-j-1, i))
				)
		self.Image = im
		self.updateImage(self.Image)

	def mirrorV(self):
		im = Image.new(mode="RGB", size=self.Image.size)
		w, h = self.Image.size
		for i in range(w) :
			for j in range(h) :
				im.putpixel(
					(i, j),
					self.Image.getpixel(
						(i, h-j-1)
					)
				)
		self.Image = im
		self.updateImage(self.Image)

	def drawCursorBorder(self, ev):
		cw = self.CursorBorderWidth
		self.Canvas.create_line(
			ev.x-cw,
			ev.y-cw,
			ev.x+cw,
			ev.y-cw,
			tag="top"
		)

		self.Canvas.create_line(
			ev.x-cw,
			ev.y-cw,
			ev.x-cw,
			ev.y+cw,
			tag="left"
		)

		self.Canvas.create_line(
			ev.x+cw,
			ev.y-cw,
			ev.x+cw,
			ev.y+cw,
			tag="right"
		)

		self.Canvas.create_line(
			ev.x - cw,
			ev.y + cw,
			ev.x + cw,
			ev.y + cw,
			tag="bottom"
		)

	def onCanvasMouseMotion(self, ev):
		px = self.Image.getpixel((ev.x, ev.y))
		self.Root.title(
			"x:%d y:%d #%x%x%x Intensity:%d%%" \
				% (
					ev.x, ev.y,
					px[0], px[1], px[2],
					int((px[0]+px[1]+px[2])/3/256 * 100)
			)
		)
		for i in ["top", "left", "right", "bottom"] :
			self.Canvas.delete(i)
		self.drawCursorBorder(ev)
	def buildHistos(self):
		for canvIdx in RGB.COLORS + [RGB.LUM] :
			self.buildHisto(canvIdx)
	def buildHisto(self, canvIdx):
		# Height array.
		canv = self.HistoCanvases[canvIdx]
		img = self.Image
		w, h = self.HistoWidth, self.HistoHeight
		# Empty array.
		ha = [0 for i in range(w) ]

		# Pixels.
		clrs = img.getcolors(
			img.size[0]*img.size[1]
		)

		# Filling array with heights up.
		for n, c in clrs :
			idx = RGB.FNLIST[canvIdx](c)
			ha[idx] += n

		maxx = float(max(ha))
		canv.delete("all")
		for i in range(w) :
			canv.create_line((i, h-1), (i, int(h-ha[i]/maxx*h)))
		
	def updateImage(self, img):
		self.Photo = ImageTk.PhotoImage(img)
		self.CanvasImage = \
			self.Canvas.create_image(0, 0, anchor="nw", image=self.Photo)
		self.buildHistos()

	def loadNewImage(self, *args):
		if not self.FirstTime :
			self.Canvas.pack_forget()
			for v in self.HistoCanvases :
				v.pack_forget()
		path = fd.askopenfilename()
		self.Image = Image.open(path).convert("RGB")
		# self.RGB = self.Image.convert("RGB")

		self.Canvas = Tk.Canvas(
			self.Root,
			width=self.Image.size[0],
			height=self.Image.size[1]
		)
			
		self.Canvas.pack()

		# Creating histogram canvases.
		canv = lambda: Tk.Canvas(
			width=self.HistoWidth,
			height=self.HistoHeight
		)
		self.HistoCanvases = []
		for i in range(len(RGB.COLORS + [RGB.LUM])) :
			c = canv()
			self.HistoCanvases.append(c)
			c.pack()

		self.updateImage(self.Image)
		self.Canvas.bind("<Motion>", self.onCanvasMouseMotion)
		if self.FirstTime :
			self.FirstTime = False

app = App()
app.Start()

